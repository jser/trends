// LICENSE : MIT
// Original from http://facebook.github.io/flux/docs/flux-utils.html#container
// This Container depended on https://github.com/azu/material-flux
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _materialFlux = require("material-flux");

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function assertBaseComponent(o) {
    (0, _assert2.default)(o.getStores, 'Components that use Container must implement `static getStores()`');
    (0, _assert2.default)(o.calculateState, 'Components that use Container must implement `static calculateState()`');
}

var Container = (function () {
    function Container() {
        _classCallCheck(this, Container);
    }

    _createClass(Container, null, [{
        key: "create",

        /**
         * Create Container of Base Component and return Container Component.
         * @param Base
         * @returns {React.Component}
         */
        value: function create(Base) {
            assertBaseComponent(Base);
            // define as Container class

            var ContainerComponent = (function (_Base) {
                _inherits(ContainerComponent, _Base);

                function ContainerComponent(props) {
                    _classCallCheck(this, ContainerComponent);

                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ContainerComponent).call(this, props));

                    _this.state = Base.calculateState(null, props);
                    // initialize
                    _this._StoreRemoveEventListers = [];
                    return _this;
                }

                _createClass(ContainerComponent, [{
                    key: "componentDidMount",
                    value: function componentDidMount() {
                        var _this2 = this;

                        if (_get(Object.getPrototypeOf(ContainerComponent.prototype), "componentDidMount", this)) {
                            _get(Object.getPrototypeOf(ContainerComponent.prototype), "componentDidMount", this).call(this);
                        }

                        var stores = Base.getStores();

                        // This tracks when any store has changed and we may need to update.
                        var changed = false;
                        var setChanged = function setChanged() {
                            changed = true;
                        };

                        // This adds subscriptions to stores. When a store changes all we do is
                        // set changed to true.
                        this._StoreRemoveEventListers = stores.map(function (store) {
                            return store.onChange(setChanged);
                        });

                        // This callback is called after the dispatch of the relevant stores. If
                        // any have reported a change we update the state, then reset changed.
                        var callback = function callback() {
                            if (changed) {
                                _this2.setState(function (prevState) {
                                    return Base.calculateState(prevState, _this2.props);
                                });
                            }
                            changed = false;
                        };
                        this._storeGroup = new _materialFlux.StoreGroup(stores, callback);
                    }
                }, {
                    key: "componentWillReceiveProps",
                    value: function componentWillReceiveProps(nextProps, nextContext) {
                        if (_get(Object.getPrototypeOf(ContainerComponent.prototype), "componentWillReceiveProps", this)) {
                            _get(Object.getPrototypeOf(ContainerComponent.prototype), "componentWillReceiveProps", this).call(this, nextProps, nextContext);
                        }
                        // TODO: pure options?
                        // Finally update the state using the new props.
                        this.setState(function (prevState) {
                            return Base.calculateState(prevState, nextProps);
                        });
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function componentWillUnmount() {
                        if (_get(Object.getPrototypeOf(ContainerComponent.prototype), "componentWillUnmount", this)) {
                            _get(Object.getPrototypeOf(ContainerComponent.prototype), "componentWillUnmount", this).call(this);
                        }

                        this._storeGroup.release();
                        this._StoreRemoveEventListers.forEach(function (removeEventListener) {
                            removeEventListener();
                        });
                        this._StoreRemoveEventListers = [];
                    }
                }]);

                return ContainerComponent;
            })(Base);

            // Update the name of the container before returning.

            var componentName = Base.displayName || Base.name;
            ContainerComponent.displayName = 'Container(' + componentName + ')';
            return ContainerComponent;
        }
    }]);

    return Container;
})();

exports.default = Container;
module.exports = exports['default'];
//# sourceMappingURL=material-container.js.map