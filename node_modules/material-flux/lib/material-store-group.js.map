{"version":3,"sources":["../src/material-store-group.js"],"names":[],"mappings":";AACA,YAAY,CAAC;;;;;;;;;sBACM,QAAQ;;;;AAC3B,SAAS,qBAAqB,CAAC,MAAM,EAAE;AACnC,6BACI,MAAM,IAAI,MAAM,CAAC,MAAM,EACvB,mDAAmD,CACtD,CAAC;AACF,QAAI,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC;AAC9C,QAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE;AACvC,cAAM,CAAC,OAAO,CAAC,UAAA,KAAK,EAAI;AACpB,qCACI,KAAK,CAAC,OAAO,CAAC,UAAU,KAAK,UAAU,EACvC,6DAA6D,CAChE,CAAC;SACL,CAAC,CAAC;KACN;AACD,WAAO,UAAU,CAAC;CACrB;;IAEoB,cAAc;;;;;;;AAMpB,aANM,cAAc,CAMnB,MAAM,EAAE,QAAQ,EAAE;;;8BANb,cAAc;;AAO3B,YAAI,CAAC,WAAW,GAAG,qBAAqB,CAAC,MAAM,CAAC,CAAC;;;AAGjD,YAAI,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,UAAA,KAAK,EAAI;AAClC,qCAAO,KAAK,CAAC,MAAM,EAAK,KAAK,CAAC,WAAW,CAAC,IAAI,oCAClD,KAAK,CAAC,WAAW,CAAC,IAAI,0JAOhB,CAAC;AACH,mBAAO,KAAK,CAAC,MAAM,CAAC;SACvB,CAAC,CAAC;;;AAGH,YAAI,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,UAAA,OAAO,EAAI;AACvD,kBAAK,WAAW,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACtC,oBAAQ,EAAE,CAAC;SACd,CAAC,CAAC;KACN;;AA5BgB,kBAAc,WA8B/B,OAAO,GAAA,mBAAG;AACN,YAAI,CAAC,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;KACpD;;WAhCgB,cAAc;;;qBAAd,cAAc","file":"material-store-group.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport assert from \"assert\";\nfunction _getUniformDispatcher(stores) {\n    assert(\n        stores && stores.length,\n        'Must provide at least one store to FluxStoreGroup'\n    );\n    var dispatcher = stores[0].context.dispatcher;\n    if (process.env.NODE_ENV !== 'production') {\n        stores.forEach(store => {\n            assert(\n                store.context.dispatcher === dispatcher,\n                'All stores in a FluxStoreGroup must use the same dispatcher'\n            );\n        });\n    }\n    return dispatcher;\n}\n\nexport default class FluxStoreGroup {\n    /**\n     * Create StoreGroup\n     * @param {MaterialStore[]} stores stores are instance of MaterialStore\n     * @param {Function} callback callback is called after store's\n     */\n    constructor(stores, callback) {\n        this._dispatcher = _getUniformDispatcher(stores);\n\n        // Precompute store tokens.\n        var storeTokens = stores.map(store => {\n            assert(store._token, `${store.constructor.name} never register key.\nclass ${store.constructor.name} extends Store {\n    constructor(..args){\n        super(..args);\n        // Needed!\n        this.register(key, handler);\n    }\n}\n            `);\n            return store._token;\n        });\n\n        // Register with the dispatcher.\n        this._dispatchToken = this._dispatcher.register(payload => {\n            this._dispatcher.waitFor(storeTokens);\n            callback();\n        });\n    }\n\n    release() {\n        this._dispatcher.unregister(this._dispatchToken);\n    }\n}"]}