// LICENSE : MIT
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _events = require("events");

var _objectAssign = require("object-assign");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var MaterialStore = (function (_EventEmitter) {
    _inherits(MaterialStore, _EventEmitter);

    function MaterialStore(context) {
        _classCallCheck(this, MaterialStore);

        _EventEmitter.call(this);
        if (process.env.NODE_ENV !== 'production') {
            require("assert")(typeof context !== "undefined", "Constructor arguments is undefined.\n                Please `new " + this.constructor.name + "(context)`\n                ");
        }
        this.context = context;
        this.state = undefined;
        this._handlers = {};
    }

    MaterialStore.prototype.register = function register(eventKey, handler) {
        if (process.env.NODE_ENV !== 'production') {
            require("assert")(typeof this.context !== "undefined", "Failed register event handler to store.\n                 \"" + this.constructor.name + "\" has not context.\n                 Please `new " + this.constructor.name + "(context)`");
            require("assert")(typeof eventKey !== "undefined", "register Error: \"eventKey\" is undefined.\n                Failed register event handler to store with eventKey.\n                Please register(eventKey, handler);\n                ");
        }
        if (typeof handler !== 'function') {
            return;
        }
        this._handlers[eventKey] = handler.bind(this);
        this.context._registerStore(this);
    };

    /**
     * This handler is dispatched with payload by context module.
     * @param {object} payload the payload has eventKey and passing arguments.
     */

    MaterialStore.prototype.handler = function handler(payload) {
        var args = payload.args;
        var eventKey = payload.eventKey;

        if (typeof this._handlers[eventKey] === "function") {
            var handler = this._handlers[eventKey];
            handler.apply(this, args);
        }
    };

    /**
     * add listener to "change" event.
     * @param {Function} callback event handler
     * @return {Function} removeChangeListener function
     * @example
     *
     * let remove = store.onChange(() => {});
     * remove(); // remove this onChange
     */

    MaterialStore.prototype.onChange = function onChange(callback) {
        this.on("change", callback);
        return this.removeChangeListener.bind(this, callback);
    };

    /**
     * remove "change" listener
     * @param {Function} callback event handler
     */

    MaterialStore.prototype.removeChangeListener = function removeChangeListener(callback) {
        this.removeListener("change", callback);
    };

    /**
     * remove all "change" events
     */

    MaterialStore.prototype.removeAllChangeListeners = function removeAllChangeListeners() {
        this.removeAllListeners("change");
    };

    /**
     * Waits for the callbacks with the specified IDs to be invoked before continuing execution
     * of the current callback. This method should only be used by a callback in response
     * to a dispatched payload.
     */

    MaterialStore.prototype.waitFor = function waitFor(tokensOrStores) {
        // _waitFor come from context module.
        this._waitFor(tokensOrStores);
    };

    /**
     * Return state object that shallowly clone store's `state`.
     * @return {object} shallow copied state
     */

    MaterialStore.prototype.getState = function getState() {
        return (0, _objectAssign2["default"])({}, this.state);
    };

    /**
     * Update `this.state` with `newState` and notify "change" event.
     * @param {object} newState
     */

    MaterialStore.prototype.setState = function setState(newState) {
        if (typeof this.state === 'undefined') {
            this.state = {};
        }

        this.state = (0, _objectAssign2["default"])({}, this.state, newState);
        this.emitChange();
    };

    /**
     * force notify "change" event
     * you should use this instead of `setState()` as force emit "change"
     */

    MaterialStore.prototype.emitChange = function emitChange() {
        this.emit('change');
    };

    return MaterialStore;
})(_events.EventEmitter);

exports["default"] = MaterialStore;
module.exports = exports["default"];
//# sourceMappingURL=material-store.js.map